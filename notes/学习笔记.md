# 任务一：函数式编程范式

## 1.1.1 课程介绍

## 1.1.2 为什么要学习函数式编程

- 随着 react 的流行越来越受到关注
- Vue3 也开始用
- 可以抛弃 this
- 打包过程中可以更好利用 tree shaking 过滤无用代码
- 方便测试，方便并行处理
- 有很多库：lodash，underscore，ramda

## 1.1.3 函数式编程概念

1. Functional Programming（FP）

   - 编程范式之一，其他还是面向过程（按步骤）和面向对象（封装继承多态）编程

2. 函数式编程的思维方式：把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）

   - x->f(联系，映射) ->y, y=f(x)
   - 函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数即映射关系如 y=sin(X)
   - 相同的输入始终要得到相同的输出（纯函数）
   - 函数式编程用来描述数据（函数）之间的映射

3. 例子对比

   - ```javascript
     //非函数式
     let num1 = 2;
     let num2 = 3;
     let sum = num1 + num2;
     console.log(sum);
     ```

   - ```javascript
     //函数式
     function add(n1, n2) {
       return n1 + n2;
     }
     let sum = add(2, 3);
     console.log(sum);
     ```

## 1.1.4 函数是一等公民

1. MDN First-class Function

   - 函数可以储存在变量中

   - 函数作为参数

   - 函数作为返回值

2. 在 JS 中函数就是一个普通的对象（可以通过 new Function()），我们可以把函数储存到变量/数组中，它还可以作为另一个函数的参数和返回值，甚至可以在程序运行的时候通过 new Function('alert(1)')来构造一个新的函数。

3. 函数复制给变量代码

   ```javascript
   //把函数复制给变量
   let fn = function () {
     console.log('Hello")
   }
   fun()

   //一个示例
   const blogController = {
     index(posts) {return Views.index(posts)},
     show(post) {return Views.show(post)},
     create(attrs) {return Db.create(attrs)},
     update(post,attrs) {return Db.update(post, attrs)},
     destroy(post) {return Db.destroy(post)}
   }

   //优化
   const blogController = {
     index: Views.index,
     show: Views.show,
     create: Db.create,
     update: Db.update,
     destroy: Db.destroy
   }
   ```

4. 函数是一等公民是高阶函数和柯里化的基础

## 1.1.5 高阶函数 - 函数作为参数

1. 什么是高阶函数

   - 高阶函数（Higher-order Function）
     - 可以把函数作为参数传递给另一个函数
     - 可以把函数作为另一个函数的返回结果

2. 函数作为参数代码案例

   ```javascript
   //高阶函数-函数作为参数
   function forEach(array, fn) {
     for (let i = 0; i < array.length; i++) {
       fn(array[i]);
     }
   }

   //测试
   let arr = [1, 3, 4, 7, 8];

   forEach(arr, function (item) {
     console.log(item);
   });

   //filter
   function filter(array, fn) {
     let results = [];
     for (let i = 0; i < array.length; i++) {
       if (fn(array[i])) {
         results.push(array[i]);
       }
     }
     return results;
   }

   //test
   let r = filter(arr, function (item) {
     return item % 2 === 0;
   });
   console.log(r);
   ```

## 1.1.6 高阶函数 - 函数作为返回值

```javascript
//函数作为返回值
function makeFn() {
  let msg = "hello";
  return function () {
    console.log(msg);
  };
}

const fn = makeFn();
fn();

//or
makeFn()();

//once函数 只执行一次
function once(fn) {
  let done = false;
  return function () {
    if (!done) {
      done = true;
      return fn.apply(this, arguments);
    }
  };
}

//test
let pay = once(function (money) {
  console.log(`pay ${money}`);
});

pay(5);
pay(5);
pay(5);
pay(5);
```

## 1.1.7 高阶函数的意义

1. 抽象可以屏蔽细节，只需要关注目标

2. 高阶函数式用来抽象通用的问题

3. code

   ```javascript
   //面向过程的方式
   let array = [1,2,3,4]
   for (let i = 0; i < array.length; i++) {
     console.log(array[i])
   }

   //高阶函数
   let array = [1,2,3,4]
   forEach(array, item => {
     console.log(item)
   }
   let r = filter(array, item => {
           return item % 2 === 0
           }
   ```

## 1.1.8 常用的高阶函数

1. list

   - forEach
   - map
   - filter
   - every
   - some
   - find/findIndex
   - reduce
   - sort
   - ......

2. ```javascript
   //模拟map every some

   //map（遍历数组挨个进行一些操作）
   const map = (array, fn) => {
     let results = [];
     for (let value of array) {
       results.push(fn(value));
     }
     return results;
   };

   //test
   let arr2 = [1, 2, 3, 4];
   arr2 = map(arr2, (v) => v * v);
   console.log(arr2);

   //every(检测数组中的元素是否都满足条件)
   const every = (array, fn) => {
     let result = true;
     for (let value of array) {
       result = fn(value);
       if (!result) {
         break;
       }
     }
     return result;
   };

   //test
   let arr3 = [9, 12, 14];
   let r2 = every(arr3, (v) => v > 10);
   console.log(r2);

   //some(检测数组中的元素是否有一个满足条件)
   const some = (array, fn) => {
     let result = false;
     for (let value of array) {
       result = fn(value);
       if (result) {
         break;
       }
     }
     return result;
   };

   //test
   let arr4 = [1, 3, 5, 9];
   let r3 = some(arr4, (v) => v % 2 === 0);
   console.log(r3);
   ```

## 1.1.9 闭包 - 概念

1. 闭包的概念：（Closure）

   ​ 函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包

   - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员

2. code 案例

   ```javascript
   //函数作为返回值
   //fn可以访问到msg，msg没有被释放因为有被引用
   function makeFn() {
     let msg = "hello";
     return function () {
       console.log(msg);
     };
   }

   const fn = makeFn();
   fn();

   //once函数 只执行一次
   //延长内部变量作用范围
   function once(fn) {
     let done = false;
     return function () {
       if (!done) {
         done = true;
         return fn.apply(this, arguments);
       }
     };
   }
   let pay = once(function (money) {
     console.log(`pay ${money}`);
   });
   //只会支付一次
   pay(5);
   pay(5);
   ```

3. 闭包的本质：

   ​ 函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问到外部函数的成员

   （当另一个作用域调用内部函数的时候可以访问到外部函数的变量）

4. 闭包的好处：

   ​ 延长了外部函数内部变量的作用范围

## 1.1.10 闭包 - 案例

案例 1:

```javascript
function makePower(power) {
  return function (number) {
    return Math.pow(number, power);
  };
}

//求平方
let power2 = makePower(2);
let power3 = makePower(3);

console.log(power2(4));
console.log(power2(5));
console.log(power3(4));
```

案例 2:

```javascript
function makeSalary(base) {
  return function (performance) {
    return base + performance;
  };
}

let salaryLevel1 = makeSalary(12000);
let salaryLevel2 = makeSalary(15000);

console.log(salaryLevel1(2000));
console.log(salaryLevel2(3000));
```

## 1.1.11 纯函数 - 概念

1. 纯函数（Pure Functions）

   - 概念：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

     - 纯函数就类似数学中的函数（用来描述输入和输出之间的关系），y=f(x)

     - 此处有图

     - lodash 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法

     - 数组的 slice 和 splice 分别是：纯函数和不纯函数

       (1) slice 返回数组中的指定部分，不会改变原数组

       (2) splice 对数组进行操作返回该数组，会改变原数组

     ```javascript
     //纯函数和不纯的函数
     //slice/splice

     let array5 = [1, 2, 3, 4, 5];

     //结果相同，纯函数
     //第一个参数：从哪开始；第二个参数：到哪结束（不包括自己）
     console.log(array5.slice(0, 3));
     //=>[1,2,3]
     console.log(array5.slice(0, 3));
     //=>[1,2,3]
     console.log(array5.slice(0, 3));
     //=>[1,2,3]

     //修改原数组，结果不同，不纯的函数
     //第一个参数：从哪个位置开始截取；第二个参数：截取几个元素，3个就是3
     console.log(array5.splice(0, 3));
     //=>[1,2,3]
     console.log(array5.splice(0, 3));
     //=>[4,5]
     console.log(array5.splice(0, 3));
     //=>[]

     //纯函数
     function getSum(n1, n2) {
       return n1 + n2;
     }
     console.log(getSum(1, 2));
     console.log(getSum(1, 2));
     console.log(getSum(1, 2));
     ```

     - 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）
     - 我们可以把一个函数的执行结果交给另一个函数去处理

## 1.1.12 Lodash - 纯函数的代表

1. JS 的一个库 Library

   ​ lodash.com

2. Lodash 常用方法演示

   ```javascript
   //演示lodash
   //first / last / toUpper / reverse / each / inCludes / find / findIndex
   const _ = require("lodash");

   const array = ["jack", "tom", "lucy", "kate"];
   console.log(_.first(array)); //jack
   console.log(_.last(array)); //kate

   console.log(_.toUpper(_.first(array))); //JACk

   //array中的reverse方法不是一个纯函数，因为它没有参数
   array.reverse;

   console.log(_.reverse(array)); //[ 'kate', 'lucy', 'tom', 'jack' ]

   const r = _.each(array, (item, index) => {
     console.log(item, index);
   });
   console.log(r);
   //kate 0
   //lucy 1
   //tom 2
   //jack 3
   //[ 'kate', 'lucy', 'tom', 'jack' ]
   //each方法的返回结果就是这个数组本身，因为之前做过倒序处理，打印的就是倒序形式

   //inCludes / find / findIndex 是ES6后新增方法
   ```

## 1.1.13 纯函数 - 优势

1. 纯函数的好处：

   - 可缓存

     - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来

     ```javascript
     //记忆函数
     const _ = require("lodash");

     function getArea(r) {
       console.log(r); //只会被执行一次
       return Math.PI * r * r;
     }

     let getAreaWithMemory = _.memoize(getArea);
     console.log(getAreaWithMemory(4));
     console.log(getAreaWithMemory(4));
     console.log(getAreaWithMemory(4));

     //模拟memoize方法的实现
     //input一个纯函数，返回一个函数
     function memoize(f) {
       let cache = {};
       return function () {
         let key = JSON.stringify(arguments); //arguments伪数组
         //先获取缓存值，如果有直接返回
         //没有的话就调用f，当调用f的时候把参数传递进来
         cache[key] = cache[key] || f.apply(f, arguments);
         return cache[key];
       };
     }

     let getAreaWithMemory2 = memoize(getArea);
     console.log(getAreaWithMemory2(4));
     console.log(getAreaWithMemory2(4));
     console.log(getAreaWithMemory2(4));
     ```

   - 可测试

     - 纯函数让测试更方便

   - 并行处理

     - 在多线程环境下并行操作共享的内存数据（比如全局变量）很可能会出现意外情况
     - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）

## 1.1.14 纯函数 - 副作用

1. 概念：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

   ```javascript
   //不纯的 -> mini变了的话输出就会变
   let mini = 18;
   function checkAge(age) {
     return age >= mini;
   }

   //纯的（有hard coding，后续可以通过柯里化解决）
   //mini变成局部变量
   function checkAge(age) {
     let mini = 18;
     return age >= mini;
   }
   ```

2. 副作用让一个函数变得不纯（如上图），纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用

3. 副作用来源（例子中的副作用来源于全局变量）：

   - 配置文件
   - 数据库
   - 获取用户的输入所有

4. 总结：所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降部署和扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

## 1.1.15 柯里化 - 概念

1. 柯里化（Haskell Brooks Curry)

2. 使用柯里化解决上一个案例中硬编码的问题

   ```javascript
   //柯里化演示
   function checkAge(age) {
     let min = 18;
     return age >= min;
   }

   //改造成一个普通的纯函数
   function checkAge2(min, age) {
     return age >= min;
   }

   console.log(checkAge2(18, 20));
   console.log(checkAge2(18, 24));
   console.log(checkAge2(22, 24));

   //让18避免重复 -> 闭包 -> 柯里化
   //什么是柯里化：当函数有多个参数的时候可以对函数进行改造。可以调用一个函数只传递部分的参数，
   //让这个函数返回一个新的函数，这个新的函数接收剩余的参数，并且返回相应的结果
   function checkAge3(min) {
     return function (age) {
       return age >= min;
     };
   }

   let checkAge18 = checkAge3(18);
   let checkAge20 = checkAge3(20);

   console.log(checkAge18(20));
   console.log(checkAge18(24));

   //使用es6箭头函数
   let checkAge4 = (min) => (age) => age >= min;

   let checkAge19 = checkAge4(19);
   let checkAge21 = checkAge4(21);
   console.log(checkAge19(20));
   console.log(checkAge21(24));
   ```

3. 柯里化（Currying）

   - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
   - 然后返回一个新的函数接收剩余的参数，返回结果

## 1.1.16 柯里化 - Lodash 中的柯里化方法

1. lodash 中的通用的柯里化方法

   - \_.curry(func)

     - 功能： 创建一个函数，该函数接收一个或多个 func 的参数，如果 func 所需要的参数都被提供则执行 func 并返回执行的结果，否则继续返回该函数并等待接收剩余的参数。
     - 参数：需要柯里化的函数
     - 返回值：柯里化后的函数

   - 代码演示

     ```javascript
     const _ = require("lodash");
     //需要柯里化的函数
     function getSum(a, b, c) {
       return a + b + c;
     }
     //柯里化后的函数
     let curried = _.curry(getSum);
     //测试
     curried(1, 2, 3);
     curried(1)(2)(3);
     curried(1, 2)(3);
     //----------------------------------------------------------------------------------
     //vscode
     //lodash中的curry基本使用
     const _ = require("lodash");

     //3个参数 -> 3元函数
     //柯里化最终可以帮我们把任意多参数的函数转化为一元函数，即只有一个参数的函数
     function getSum(a, b, c) {
       return a + b + c;
     }

     const curried = _.curry(getSum);
     //结果都是一样的：6
     console.log(curried(1, 2, 3));
     console.log(curried(1)(2, 3));
     console.log(curried(1)(2)(3));
     console.log(curried(1, 2)(3));
     ```

## 1.1.17 柯里化 - 案例

```javascript
//柯里化案例
//正则表达式：// -> /\s/ 空白字符 -> /\s+/ 任意多个空白字符 -> /\s+/g 全局匹配
"".match(/\s+/g);
"".match(/\d+/g); //\d 数字

const __ = require("lodash");

const match = __.curry(function (reg, str) {
  return str.match(reg);
});

const haveSpace = match(/\s+/g);
console.log(haveSpace("hello world")); // 会把空白字符以一个数组的形式打印出来[ ' ' ]
console.log(haveSpace("helloworld")); // null

const haveNumber = match(/\d+/g);
console.log(haveNumber("123abc")); // [ '123' ]
console.log(haveNumber("abc")); // null

//柯里化filter函数
const filter = __.curry(function (func, array) {
  return array.filter(func);
});

console.log(filter(haveSpace, ["John Connor", "John_Donne"]));

const findSpace = filter(haveSpace); //可以重复使用
console.log(findSpace(["John Connor", "John_Donne"]));
```

## <u>1.1.18 柯里化 - 原理模拟（实现原理）</u>

```javascript
//柯里化原理
function curry(func) {
  //...：rest剩余参数，args是一个数组
  return function curriedFn(...args) {
    //判断实参和形参的个数
    //args.length实参；func.length形参
    if (args.length < func.length) {
      //闭包
      return function () {
        return curriedFn(...args.concat(Array.from(arguments)));
      };
    }
    //两种方法展开args传参：1.apply；2.es6中的...
    return func(...args);
  };
}

//test
function getSum2(a, b, c) {
  return a + b + c;
}
const curried2 = curry(getSum);
console.log(curried2(1, 2, 3));
console.log(curried2(1)(2, 3));
console.log(curried2(1)(2)(3));
console.log(curried2(1, 2)(3));
```

## 1.1.19 柯里化 - 总结

1. 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
   - 比如 match 例子可以生成新函数 haveSpace，内部使用闭包记住了传递的正则表达式，这是柯里化的核心
2. 这是一种对函数参数的‘缓存’ （使用闭包）
3. 让函数变得更灵活，让函数的粒度更小
   - 目的后续学组合的时候使用
4. 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能
   - 把很多一元函数组合起来

## 1.1.20 函数组合 - 概念

1. 纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))

   - 获取数组的最后一个元素再转换成大写字母：_.toUpper(_.first(\_.reverse(array)))

   - 函数组合可以让我们把细粒度的函数重新组合生成一个新的函数

2. 数据的管道

   - ![Screen Shot 2020-09-22 at 9.44.37 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-22 at 9.44.37 PM.png)

   - 给 fn 输入 a，返回结果 b，fn 就是这个处理数据的管道
   - 当 fn 比较复杂的时候，可以拆分成多个小函数，此时多了中间运算过程产生的 m 和 n
   - 出现问题好定位
   - ![Screen Shot 2020-09-22 at 9.46.16 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-22 at 9.46.16 PM.png)

   ```javascript
   fn = compose(f1, f2, f3);
   b = fn(a);
   ```

3. 函数组合

   - 函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数

     - 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果
     - 函数组合默认从右到左执行

   - ```javascript
     //函数组合演示
     function compose(f, g) {
       return function (value) {
         return f(g(value));
       };
     }

     function reverse(array) {
       return array.reverse();
     }

     function first(array) {
       return array[0];
     }

     const last = compose(first, reverse); //从右到左

     console.log(last([1, 2, 3, 4]));
     ```

## 1.1.21 函数组合 - Lodash 中的组合函数

1. Lodash 中的组合函数

   - lodash 中组合函数 flow()或者 flowRight()，他们都可以组合多个函数
   - Flow()是从左到右运行
   - flowRight()是从右到左运行，使用的更多一些

2. 演示

   ```javascript
   //lodash中的函数组合的方法：_.flowRight()
   const _ = require("lodash");

   const reverse2 = (arr) => arr.reverse();
   const first2 = (arr) => arr[0];
   const toUpper = (s) => s.toUpperCase();

   const f = _.flowRight(toUpper, first2, reverse2);

   console.log(f(["one", "two", "three"]));
   ```

## 1.1.22 函数组合 - 组合函数的实现原理（原理模拟）

```javascript
// 模拟lodash中的flowRight
function flowRight(...args) {
  return function (value) {
    // reduce 方法：对数组中每一个元素执行由我们提供的一个函数，并将其汇总成一个单个的结果
    return args.reverse().reduce(function (acc, fn) {
      return fn(acc);
    }, value);
    //value：acc初始值
  };
}
// test
const f2 = flowRight(toUpper, first2, reverse2);
console.log(f(["one", "two", "three"]));

// 改造
const flowRight2 = (...args) => (value) =>
  args.reverse().reduce((acc, fn) => fn(acc), value);
//test
const f3 = flowRight2(toUpper, first2, reverse2);
console.log(f(["one", "two", "three"]));
```

## 1.1.23 函数组合 - 结合律

1. 函数的组合要满足结合律(associativity)

   - 我们就可以把 g 和 h 组合，还可以把 f 和 g 组合，结果都是一样的

   - ```javascript
     //结合律
     let f = compose(f, g, h);
     let associative = compose(compose(f, g), h) == compose(f, compose(g, h));
     //true
     ```

2. 案例

   ```javascript
   //函数组合要满足结合律
   const f4 = _.flowRight(_.toUpper, _.first, _.reverse);
   console.log(f4(["one", "two", "three"]));
   //改造
   //先组合后两个
   const f5 = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse);
   console.log(f5(["one", "two", "three"]));
   //先组合前两个
   const f6 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse));
   console.log(f6(["one", "two", "three"]));
   ```

## 1.1.24 函数组合 - 调试

1. 如何调试组合函数

   ```javascript
   const f = _.flowRight(_.toUpper, _.first, _.reverse);
   console.log(f(["one", "two", "three"]));
   ```

2. 案例

   ```javascript
   //函数组合 调试
   //NEVER SAY DIE --> never-say-die

   const _ = require("lodash");

   const log = (v) => {
     console.log(v);
     return v;
   };

   //改造log
   const trace = _.curry((tag, v) => {
     console.log(tag, v);
     return v;
   });

   //_.split()
   const split = _.curry((sep, str) => _.split(str, sep));

   //_.toLower(); 只有一个参数，不需要改造

   //_.join()
   const join = _.curry((sep, array) => _.join(array, sep));
   //_.map()
   const map = _.curry((fn, array) => _.map(array, fn));
   //log定位错误点
   const f = _.flowRight(join("-"), log, map(_.toLower), split(" "));
   const f2 = _.flowRight(
     join("-"),
     trace("after map"),
     map(_.toLower),
     trace("after split"),
     split(" ")
   );
   console.log(f("NEVER SAY DIE"));
   console.log(f2("NEVER SAY DIE"));
   ```

## 1.1.25 Lodash - Lodash 中的 FP 模块

1. FP：Functional Programming

2. lodash/fp

   - lodash 的 fp 模块提供了实用的对**函数式编程友好**的方法
   - 提供了不可变的 **<u>auto-curried iteratee-first data-last</u>** 的方法

3. 演示

   ```javascript
   //lodash模块
   const _ = require("lodash");

   _.map(["a", "b", "c"], _.toUpper); //数据优先，函数在后
   // => ['A','B','C']
   _.map(["a", "b", "c"]); //没有传方法，返回原数组
   // => ['a','b','c']

   _.split("Hello World", " ");

   //lodah/fp 模块
   const fp = require("lodash/fp");

   fp.map(fp.toUpper, ["a", "b", "c"]); //函数优先，数据在后
   fp.map(fp.toUpper)(["a", "b", "c"]); //柯里化过的函数

   fp.split(" ", "Hello World");
   fp.split(" ")("Hello World");
   ```

4. 案例

   ```javascript
   //lodash的fp模块
   //NEVER SAY DIE --> never-say-die
   const fp = require("lodash/fp");

   const f = fp.flowRight(fp.join("-"), fp.map(fp.toLower), fp.split(" "));

   console.log(f("NEVER SAY DIE"));
   ```

## <u>1.1.26 Lodash - map 方法的区别（小问题）</u>

```javascript
//lodash 和lodahs/fp 模块中map方法的区别
const _ = require("lodash");
const fp = require("lodash/fp");

console.log(_.map(["23", "8", "10"], parseInt));
//parseInt('23',0,array) 十进制
//parseInt('8',1,array) 无法识别
//parseInt('10',2,array) 二进制

console.log(fp.map(parseInt), ["23", "8", "10"]);
```

## 1.1.27 Point Free

1. Point Free 概念：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

   - 不需要指明处理的数据

   - **只需要合成运算过程**

   - 需要定义一些辅助的基本运算函数

   - ```javascript
     const f = fp.flowRight(fp.join("-"), fp.map(fp.toLower), fp.split(" "));
     ```

2. 案例

   ```js
   //非point free模式
   //Hello World -> hello_world
   function f(word) {
     return word.toLowerCase().replace(/\s+/g, "_");
   }

   //point free
   const fp = require("lodash/fp");
   const f = fp.flowRight(fp.replace(/\s+/g, "_"), fp.toLower);
   console.log(f("Hello World"));
   console.log(f("Hello      World"));
   //输出都是hello_world
   ```

3. 实现方式：函数的组合

## 1.1.28 Point Free - 案例

```js
//把一个字符串中的首字母提取并转换成大写，使用.作为分隔符
//world wild web -> W. W. W

const fp = require("lodash/fp");

//思路：1. 先用空格进行切割变成一个数组； 2. 数组中每一项转换成大写 3. 数组中每一项的第一个字符取出； 4. 使用.把每一项连接起来
const firstLetterToUpper = fp.flowRight(
  fp.join(". "),
  fp.map(fp.first),
  fp.map(fp.toUpper),
  fp.split(" ")
);

console.log(firstLetterToUpper("world wild web"));

//改进:只用一次map循环
，把first和toUpper再结合一次
const firstLetterToUpper2 = fp.flowRight(
  fp.join(". "),
  fp.map(fp.flowRight(fp.first, fp.toUpper)),
  fp.split(" ")
);
console.log(firstLetterToUpper2("world wild web"));
```

## 1.1.29 函子（Functor）- 概念

1. 为什么要学习函子：

   - 目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把负作用控制在可控的范围内、异常处理、异步操作等。

2. 什么是 Functor：

   - 容器：包含值和值的变形关系（这个变形关系就是函数）
   - 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理（变形关系）

3. 演示

   ```js
   // Functor 函子
   class Container {
     constructor(value) {
       this._value = value; //_:private
     }

     map(fn) {
       return new Container(fn(this._value));
     }
   }

   let r = new Container(5).map((x) => x + 1).map((x) => x * x);
   console.log(r); //Container { _value: 36 }

   //改进 函数式编程思想
   class Container2 {
     static of(value) {
       return new Container(value);
     }
     constructor(value) {
       this._value = value; //_:private
     }

     map(fn) {
       return Container2.of(fn(this._value));
     }
   }

   let r2 = Container2.of(5)
     .map((x) => x + 2) //返回新的函子，值为7
     .map((x) => x * x);

   console.log(r2); // Container { _value: 49 } //r2是一个函子对象，像一个盒子，值在这个盒子里

   //使用函子：链式编程
   //函子是一个具有map方法的一个对象，我们在函子里维护一个值，这个值永远不对外公布，就像这个值包裹在一个盒子里。
   //想要对这个值进行处理的话就调用map方法，通过map方法传递一个处理值的函数，map方法执行完返回一个新的函子
   //通过这个方式不停的.map进行链式调用
   ```

## 1.1.30 函子（Functor）- 总结

1. 函数式编程的运算不直接操作值，而是由函子完成

2. 函子就是一个实现了 map 契约的对象

3. 我们可以把函子想象成一个盒子，这个盒子里封装了一个值

4. 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理

5. 最终 map 方法返回一个包含新值的盒子（函子）

6. 演示：

   ```js
   //演示 null undefined 的问题
   Container2.of(null).map((x) => x.toUpperCase()); //异常空指针 -> 副作用
   ```

## 1.1.31 MayBe 函子

1. 我们在编程的过程中可能会遇到很多错误，需要对这些错误作相应的处理

2. MayBe 函子的作用就是可以对外部的空值情况作处理（控制副作用在允许的范围）

3. ```js
   const { map } = require("lodash");

   //MayBe函子
   class MayBe {
     static of(value) {
       return new MayBe(value);
     }
     constructor(value) {
       this._value = value;
     }

     map(fn) {
       return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value));
     }

     isNothing() {
       return this._value === null || this._value === undefined;
     }
   }

   let r = MayBe.of("Hello World").map((x) => x.toUpperCase());
   console.log(r); //MayBe { _value: 'HELLO WORLD' }

   let r2 = MayBe.of(null).map((x) => x.toUpperCase());
   console.log(r2); //MayBe { _value: null }

   let r3 = MayBe.of("Hello World")
     .map((x) => x.toUpperCase())
     .map((x) => null)
     .map((x) => x.split(""));
   console.log(r3); //MayBe { _value: null }
   //问题在于不知道哪次会出现null
   ```

## 1.1.32 Either 函子

1. Either 两者中的任何一个，类似于 if...else...的处理

2. 异常会让函数变得不纯，Either 函子可以用来做异常处理，并在函子中记录出错的信息

3. ```js
   //Either函子
   class Left {
     static of(value) {
       return new Left(value);
     }
     constructor(value) {
       this._value = value;
     }
     map(fn) {
       return this;
     }
   }

   class Right {
     static of(value) {
       return new Right(value);
     }
     constructor(value) {
       this._value = value;
     }
     map(fn) {
       return Right.of(fn(this._value));
     }
   }

   let r1 = Right.of(12).map((x) => x + 2);
   let r2 = Left.of(12).map((x) => x + 2);
   console.log(r1); //Right { _value: 14 }
   console.log(r2); //Left { _value: 12 }

   function parseJSON(str) {
     try {
       return Right.of(JSON.parse(str));
     } catch (e) {
       return Left.of({ error: e.message });
     }
   }

   let r3 = parseJSON("{ name: zs }");
   console.log(r3); //Left { _value: { error: 'Unexpected token n in JSON at position 2' } }

   let r4 = parseJSON('{ "name": "zs" }');
   console.log(r4); //Right { _value: { name: 'zs' } }

   let r5 = parseJSON('{ "name": "zs" }').map((x) => x.name.toUpperCase());
   console.log(r5); //Right { _value: 'ZS' }
   ```

## 1.1.33 IO 函子

1. IO 函子中的 \_value 是一个函数，这里是把函数作为值来处理

2. IO 函子可以把不纯的动作存储到 \_value 中，延迟执行这个不纯的操作（惰性执行），包装当前的操作（纯）

3. 把不纯的操作交给调用者来处理

4. ```js
   //IO函子
   const fp = require("lodash/fp");

   class IO {
     static of(value) {
       return new IO(function () {
         return value;
       });
     }
     constructor(fn) {
       this._value = fn;
     }

     map(fn) {
       //把当前的value和传入的fn组合成一个新的函数
       return new IO(fp.flowRight(fn, this._value));
     }
   }

   //调用
   let r = IO.of(process).map((p) => p.execPath);
   console.log(r); //IO { _value: [Function] }
   console.log(r._value()); //node的路径：/usr/local/bin/node

   //总结：IO函子内部帮我们包装了一些函数，传递函数的时候有可能函数是一个不纯的操作，不管纯不纯，IO函子在执行的过程中返回的结果始终是纯的操作
   //IO中有可能包括了一些不纯的操作，但是当前执行始终是纯的操作，调用map方法的时候始终会返回一个IO函子
   //_value因为要组合很多函数，有可能是不纯的，我们把不纯的操作延迟到调用的时候，把副作用控制在可控范围
   ```

## 1.1.34 folktale

1. Task 异步执行

   - 异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示
   - folktale 是一个标准的函数式编程库
     - 和 lodash，ramda 不同的是，他没有提供很多功能函数
     - 只提供了一些函数式处理的操作，例如：compose，curry 等，一些函子 Task，Either，MayBe 等

2. 演示

   ```js
   // folktale 中的 compose 和 curry
   const { compose, curry } = require("folktale/core/lambda");
   const { toUpper, first } = require("lodash/fp");

   //第一个参数是传入函数的参数个数
   let f = curry(2, (x, y) => {
     return x + y;
   });

   console.log(f(1, 2)); // 3
   console.log(f(1)(2)); // 3

   //函数组合
   let f2 = compose(toUpper, first);
   console.log(f2(["one", "two"])); // ONE
   ```

## 1.1.35 Task 函子

1. Task 异步执行

   - folktale(2.3.2) 2.x 中的 Task 和 1.0 中的 Task 区别很大，1.0 中的用法更接近我们现在演示的函子

   - 这里以 2.3.2 来演示

   - ```js
     // Task处理异步任务
     const fs = require("fs");
     const { task } = require("folktale/concurrency/task");
     const { split, find } = require("lodash/fp");

     function readFile(filename) {
       return task((resolver) => {
         //readFile异步执行读取文件，需要三个参数，第一个是文件路径，第二个是使用的编码，最后是一个回调函数(node里错误优先->错误，数据)
         fs.readFile(filename, "utf-8", (err, data) => {
           if (err) resolver.reject(err);
           resolver.resolve(data);
         });
       });
     }
     //调用run执行
     readFile("package.json")
       .map(split("\n"))
       .map(find((x) => x.includes("version")))
       .run()
       .listen({
         onRejected: (err) => {
           console.log(err);
         },
         onResolved: (value) => {
           console.log(value);
         },
       }); //  "version": "1.0.0"
     ```

## 1.1.36 Pointed 函子

1. Pointed 函子是实现了 of 静态方法的函子

2. of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context（把值放到容器中，使用 map 来处理值）

3. ![Screen Shot 2020-09-26 at 9.17.44 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-26 at 9.17.44 PM.png)

   盒子即为上下文

4. ```js
   class Container {
     //pointed函子
     static of(value) {
       return new Container(value); //获得一个上下文
     }
   }

   Container.of(2).map((x) => x + 5); //在上下文里处理数据
   ```

## <u>1.1.37 IO 函子问题</u>

1. Monad（单子）

   - 在使用 IO 函子的时候，如果我们写出如下代码

     ```js
     //io函子的问题
     const fs = require("fs");
     const fp = require("lodash/fp");

     class IO {
       static of(value) {
         return new IO(function () {
           return value;
         });
       }
       constructor(fn) {
         this._value = fn;
       }

       map(fn) {
         return new IO(fp.flowRight(fn, this._value));
       }
     }

     let readFile = function (filename) {
       return new IO(function () {
         //同步读取文件并返回文件内容
         return fs.readFileSync(filename, "utf-8");
       });
     };

     let print = function (x) {
       return new IO(function () {
         console.log(x);
         return x;
       });
     };

     let cat = fp.flowRight(print, readFile);
     //IO(IO(x)) -> 嵌套就必须._value._value
     let r = cat("package.json");
     console.log(r); //IO { _value: [Function] }
     let r2 = cat("package.json")._value();
     console.log(r2);
     //IO { _value: [Function] }
     //IO { _value: [Function] }
     let r3 = cat("package.json")._value()._value();
     console.log(r3);
     ```

## <u>1.1.38 Monad 函子</u>

1. Monad 函子是可以变扁的 Pointed 函子，IO(IO(x))

2. 一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad

3. 演示

   ```js
   // IO Monad
   const fs = require("fs");
   const fp = require("lodash/fp");

   class IO {
     static of(value) {
       return new IO(function () {
         return value;
       });
     }
     constructor(fn) {
       this._value = fn;
     }

     map(fn) {
       return new IO(fp.flowRight(fn, this._value));
     }

     join() {
       return this._value();
     }

     flatMap(fn) {
       return this.map(fn).join();
     }
   }

   let readFile = function (filename) {
     return new IO(function () {
       //同步读取文件并返回文件内容
       return fs.readFileSync(filename, "utf-8");
     });
   };

   let print = function (x) {
     return new IO(function () {
       console.log(x);
       return x;
     });
   };

   let r = readFile("package.json")
     //   .map((x) => x.toUpperCase())
     .map(fp.toUpper)
     .flatMap(print)
     .join();
   console.log(r);
   ```

4. 什么时候使用 Monald：

   ​ 当一个函数返回一个函子的时候就要想到 Monad。Monad 可以帮我们解决函子嵌套的问题。当我们想要合并一个函数，并且这个函数返回一个值，这时候可以调用 map 方法；当我们想要合并一个函数，但是这个函数返回一个函子，这个时候要用 flatMap 方法

## 1.1.39 总结

1. 4 个部分：![Screen Shot 2020-09-26 at 10.01.08 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-26 at 10.01.08 PM.png)

# 任务二：JavaScript 异步编程

## 1.2.1 概述 - 异步编程 - 单线程 JavaScript 异步方案

1. 采用单线程模式工作的原因
   - 最初是个脚本语言，用于 DOM，必须单线程，否则浏览器会有线程同步的问题
2. 核心特性：JS 执行环境中负责执行代码的线程只有一个
   - 想象成只有一个人在执行任务，如果有多个任务就必须要排队，依次完成
   - 优点：安全，简单
   - 缺点：遇到特别耗时的任务，其他任务必须排队等待。整个程序的执行会遭到拖延，出现“假死”的情况
3. JavaScript 将任务的执行模式分成了两种：
   - 同步模式（Synchronous）
   - 异步模式（Asynchronous）
4. 内容概要：
   - 同步模式与异步模式
   - 事件循环与消息队列
   - 异步编程的几种方式
   - Promise 异步方案、宏任务/微任务队列
   - Generator 异步方案、Async/Await 语法糖

## 1.2.2 同步模式 - Synchronous

1. 什么是同步执行模式：

   ​ 代码当中的任务依次执行，后一个任务必须等待前一个任务结束才能开始执行，程序的执行顺序跟代码执行顺序完全一致。

2. 在 call stack 中最先压入一个匿名函数（等于所有代码装进这个匿名函数），然后有调用的时候：压栈 -> 执行 -> 弹栈

3. JS 在执行引擎当中维护了一个正在工作的工作表，或者说正在执行的工作表，在这里会记录当前正在做的一些事情。当这个工作表当中所有任务全部被清空过后，这一轮的工作就算是结束了。

4. 存在的问题：如果其中有一个任务，某一行代码执行时间过长，后面的任务就会被延迟，这种延迟被称作堵塞。对于用户而言意味着界面的卡顿和卡死，所以必须要有异步模式来解决程序当中无法避免的耗时操作，比如浏览器端的 ajax 操作或者 node js 中的大文件读写，都会需要使用到异步模式执行来避免代码被卡死。

## 1.2.3 异步模式 - Asynchronous

1. 什么是异步执行模式：

   - 异步模式的 API 不会等待这个任务的结束才开始下一个任务
   - 对于耗时操作都是开启过后就立即往后执行下一个任务
   - 耗时操作的后续逻辑一般会通过回调函数的方式定义
     - 在内部，耗时任务完成过后就会自动执行传入的回调函数

2. 对 JS 非常重要，因为：

   - 单线程的 JS 语言无法同时处理大量耗时任务

3. 最大的难点：代码的执行顺序混乱，不通俗易懂

4. ![Screen Shot 2020-09-27 at 11.15.34 AM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-27 at 11.15.34 AM.png)

   比同步执行多了：

   - Web APIs
   - Queue 消息队列（回调队列）

5. 遇到 setTimeout 异步调用的时候：

   - 先压栈 setTimeout
   - 在 WebAPIs 中为 timer 开启了一个倒计时器（这个倒计时器是单独工作的，不会受 JS 线程影响）
   - 这个 setTimeout 调用等于完成了，弹栈
   - 当调用栈空了的时候（包括匿名函数），Event Loop 事件循环（负责监听调用栈和消息队列）就会从消息队列中取出第一个回调函数压入调用栈。
   - 此时因为 timer 还没有结束，所以消息队列为空。执行暂停。
   - 先结束的 timer 的回调会先被放入 queue。一旦 queue 发生了变化，event loop 就会监听到，把第一个取出压栈。
   - 此时对于 call stack 等于开启了新一轮执行
   - 不断重复，直到 call stack 和 queue 都没有需要执行的任务了，代码结束。

6. JS 异步调用的实现过程和基本原理：

   - 调用栈 call stack 等于一个正在执行的工作表，消息队列 Queue 等于一个待办的工作表；JS 执行引擎先做完 call stack 中所有任务，再通过 event loop 事件循环从消息队列 queue 中再取一个任务出来继续执行，以此类推。整个过程中我们随时都可以往消息队列中放入一些任务，这些任务在消息队列 queue 当中会排队等待事件循环 event loop。
   - 整个过程都是通过内部的消息队列和事件循环去实现的
   - 步骤没有先后顺序，各自有 timeline

7. 图解：

   ![Screen Shot 2020-09-27 at 11.37.42 AM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-27 at 11.37.42 AM.png)

单独线程执行等待操作，JS 线程是单线程，不等。

8. 同步异步指的是运行环境提供的 API 是以同步或异步模式的方式工作，不是指写代码的方式
   - 同步特点：代码执行完才会往下走，如 console.log
   - 异步：call 完就走，代码不会在这行等待任务执行结束，如 setTimeout

## 1.2.4 回调函数 - 所有异步编程方案的根基

1. 回调函数可以理解为一件你想要做的事情

   - 明确知道应该怎么做
   - 不知道所依赖的任务什么时候才能完成
   - 把步骤写到一个函数中，交给执行者
   - 任务结束后执行

2. 比如给桌子刷漆
   - 知道怎么刷，但没有油漆
   - 找人买油漆，需要时间，不能干等
   - 把桌子怎么刷的步骤写到纸条
   - 买完油漆后的人可以根据纸条刷
   - 我：调用者；买油漆的人：执行者；纸条：调用者定义的回调函数；

![Screen Shot 2020-09-27 at 12.30.02 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-27 at 12.30.02 PM.png)

3. 例子：AJAX

   - 目的：为了拿到请求结果后做一些事情，比如显示到界面上

   - 但是请求何时能完成不知道
   - 所以把得到相应结果后需要执行的任务写到一个函数中
   - 请求完成后自动执行这个任务

4. 总结：回调函数就是由调用者定义，交给执行者执行的函数

5. 具体用法：把函数作为参数传递

   ```js
   function foo (callback) {
     setTimeout(function () {
       callback()
     }, 3000)
   }

   foo(function() {
     console.log('这就是一个回调函数')
     console.log('调用者定义这个函数，执行者执行这个函数')
     console.log('其实就是调用者告诉执行者异步任务结束后应该做什么')
   }
   ```

6. 缺点：不利于阅读，顺序混乱

## 1.2.5 Promise - 概述 - 一种更优的异步编程统一方案

1. 如果我们直接使用传统回调方式完成复杂的异步流程，无法避免大量的回调函数嵌套（回调地狱问题 callback hell）

   ![Screen Shot 2020-09-27 at 12.39.49 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-27 at 12.39.49 PM.png)

2. 为了避免 callback hell，CommonJS 社区提出了 Promise 的规范

   - 目的：为异步编程提供更合理更强大的统一解决方案
   - 在 ES2015 中被标准化，成为语言规范

3. 什么是 Promise：

   - 是一个对象，用来表示一个异步任务最终结束后究竟是成功还是失败
   - 像内部对外界做出了一个承诺，一开始这个承诺是一个待定的状态（pending），最终有可能成功（Fulfilled）也有可能失败（Rejected）
   - 不管是成功还是失败，都会有一个相对应的反应（onFulfilled）（onRejected）
   - 也就是说在承诺状态确定了之后会有一个相对应的任务会被自动执行
   - 这个承诺有一个明显的特点：一旦明确了结果不可能再发生改变；落实到程序上，AJAX 请求成功或者失败

![Screen Shot 2020-09-27 at 12.45.39 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-09-27 at 12.45.39 PM.png)

## 1.2.6 Promise - 基本用法

```js
// Promise基本示例

const { reject } = require("lodash");

const promise = new Promise(function () {
  // 这里用于“兑现“承诺

  resolve(100); //承诺达成
  reject(new Error("promise rejected")); //承诺失败
});

promise.then(
  function (value) {
    console.log("resolved", value);
  },
  function (error) {
    console.log("reject", error);
  }
);

console.log("end"); //先end再error
```

## 1.2.7 Promise - 使用案例

```js
//promise方式的ajax
function ajax(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "json";
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    xhr.send();
  });
}

//正确路径
ajax("/api/users.json").then(
  function (res) {
    console.log(res); // data
  },
  function (error) {
    console.log(error);
  }
);

//错误路径
ajax("/api/users.json").then(
  function (res) {
    console.log(res);
  },
  function (error) {
    console.log(error); // 404 not found
  }
);
```

## 1.2.8 Promise - 常见误区

1. Promise 本质是使用回调函数去定义异步任务结束后所需要执行的任务。

2. 回调函数是通过 then 方法传递进去的。分为成功和失败：![Screen Shot 2020-10-03 at 4.25.24 PM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-10-03 at 4.25.24 PM.png)

3. 如果需要连续串联多个任务，还是会出现 call back hell 问题。比如：

   ```js
   function ajax(url) {
     return new Promise(function (resolve, reject) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url);
       xhr.responseType = "json";
       //请求完成事件
       xhr.onload = function () {
         if (this.status === 200) {
           resolve(this.response);
         } else {
           reject(new Error(this.statusText));
         }
       };
       xhr.send();
     });
   }

   //callback hell
   ajax("/api/users.json").then(function (urls) {
     ajax(urls.users).then(function (users) {});
   });
   ```

4. 嵌套使用的方式是使用 Promise 最常见的错误，正确的方法是借助于 Promise then 方法链式调用的特点，尽可能保证异步任务扁平化。

## 1.2.9 Promise - 链式调用

1. 代码演示

   ```js
   function ajax(url) {
     return new Promise(function (resolve, reject) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url);
       xhr.responseType = "json";
       //请求完成事件
       xhr.onload = function () {
         if (this.status === 200) {
           resolve(this.response);
         } else {
           reject(new Error(this.statusText));
         }
       };
       xhr.send();
     });
   }

   var promise = ajax("/api/users.json");
   // then返回一个全新的promise对象
   var promise2 = promise.then(
     function onFulfilled(value) {
       console.log("onFulfilled", value);
     },
     function onRejected(error) {
       console.log("onRejected", error);
     }
   );

   console.log(promise2);
   console.log(promise2 === promise); //false

   //返回一个全新的promise对象的目的就是实现promise链条
   //每一个then方法实际上都是在为上一个then方法返回的promise对象添加状态明确过后的回调
   //这些promise会依次执行，添加的回调函数也是从前到后依次执行
   //也可以手动返回
   ajax("/api/users.json")
     .then(function (value) {
       console.log(1111);
       return ajax("/api/users.json");
     }) // => promise
     .then(function (value) {
       console.log(2222);
       console.log(value);
     }) // => promise
     .then(function (value) {
       console.log(3333);
     }) // => promise
     .then(function (value) {
       console.log(4444);
     }) // => promise
     .then(function (value) {
       console.log(5555);
     });
   ```

2. 总结：

   - Promise 对象的 then 方法会返回一个全新的 Promise 对象
   - 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调
   - 前面的 then 方法中回调函数的返回值会作为后面 then 方法回调的参数
   - 如果回调中返回的是 Promise，那后面 then 方法的回调会等待它的结束

## 1.2.10 Promise - 异常处理

1. onRejected：对 Promise 中的异常做一些处理，Promise 失败或者出现异常就会进行处理

2. 更常见的用法：使用 catch，更适合链式调用

   ```js
   var promise = ajax("/api/users11.json");
   // then返回一个全新的promise对象
   var promise2 = promise
     .then(function onFulfilled(value) {
       console.log("onFulfilled", value);
     }) // => Promise {}
     .catch(function onRejected(error) {
       console.log("onRejected", error);
     });
   ```

3. 两种方式都能捕获异常，差异在于：

   - 使用 catch 的话是给第一个 then 方法返回的 Promise 进行失败的回调，而不是第一个 Promise，只不过是同一个链条，前面 Promise 上的异常会被一直往后传递直到被 catch
   - 使用第二个 then 方法的话只是给第一个 Promise 指定，也就是说只能捕获到第一个 Promise 的异常
   - 具体表象上的差异就是如果我们在 then 方法中返回了第二个 Promise 并且这个 Promise 执行过程中出现了异常，那么使用 then 的第二个参数去注册的失败回调是捕获不到第二个 Promise 的异常的，因为是给第一个 Promise 注册的失败回调，而使用 catch 更像是给整个链条注册的失败回调

   ```js
   // 错误路径1: 无法捕获
   ajax("/api/users11.json")
     .then(function (value) {
       console.log(1111);
       return ajax("/api/users.json");
     }) // => promise
     .then(function (value) {
       console.log(2222);
       console.log(value);
     }) // => promise
     .then(function (value) {
       console.log(3333);
     }) // => promise
     .then(function (value) {
       console.log(4444);
     }) // => promise
     .then(function (value) {
       console.log(5555);
     });

   //错误路径2:可以捕获
   ajax("/api/users11.json")
     .then(function (value) {
       console.log(1111);
       return ajax("/api/users.json");
     }) // => promise
     .then(function (value) {
       console.log(2222);
       console.log(value);
     }) // => promise
     .catch(function onRejected(error) {
       console.log("onRejected", error);
     });
   ```

4. 除此之外，我们还可以在全局对象上注册一个 unhandledrejection 事件，去处理那些代码中没有被手动捕获的 promise 异常（不推荐），应该在代码中明确捕获每一个可能的异常，而不是丢给全局统一处理

   ![Screen Shot 2020-10-06 at 11.30.27 AM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-10-06 at 11.30.27 AM.png)

   ![Screen Shot 2020-10-06 at 11.28.38 AM](/Users/yixilin/Library/Application Support/typora-user-images/Screen Shot 2020-10-06 at 11.29.43 AM.png)

## 1.2.11 Promise - 静态方法

1. Promise.resolve(): 快速把一个值转化为一个 Promise 对象

   ```js
   Promise.resolve('foo') // 返回一个状态为fulfill的Promise对象 ‘foo’作为返回的值
   	.then(function (value) {
     	console.log(value)
   })

   //等价于
   new Promise(function (resolve, reject) {
     resolve('foo')
   }

   // 如果通过Promise.resolve()去包装一个Promise，则会得到同一个对象
   var promise = ajax('/api/users.json')
   var promise2 = Promise.resolve(promise)
   console.log(promise === promise2) // true

   //如果传入了一个对象，也有一个then方法, 这样一个对象也可以作为一个promise执行，实现了thenable的借口
   //在原生promise没有普及之前都是使用第三方库，可以通过promise.resolve()转为原生promise（作为了解）
   Promise.resolve({
     then:function(onFulfilled, onRejected) {
       onFulfilled('foo')
     }
   })
   .then(function (value) {
     console.log(value)
   })
   ```

2. Promise.reject(): 创建一个一定会失败的 Promise

   ```js
   Promise.reject(new Error("rejected")).catch(function (error) {
     console.log(error);
   });
   //无论传入什么参数，都会被作为失败的原因
   Promise.reject("anything").catch(function (error) {
     console.log(error);
   });
   ```

## 1.2.12 Promise - 并行执行

1. 提供了更扁平的异步编程体验；也可以并行执行多个异步任务

2. case：页面中请求多个借口，可以同时请求

   - Promise.all()

     ​ 将多个 Promise 合并为一个 Promise 进行管理

   ```js
   //Promise并行执行

   function ajax(url) {
     return new Promise(function (resolve, reject) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url);
       xhr.responseType = "json";
       //请求完成事件
       xhr.onload = function () {
         if (this.status === 200) {
           resolve(this.response);
         } else {
           reject(new Error(this.statusText));
         }
       };
       xhr.send();
     });
   }

   ajax("/api/users.json");
   ajax("/api/posts.json");

   //麻烦的是怎么判断所有的请求都结束的时机
   //传统做法：定义一个计数器，每结束一个累计一下，直到跟任务数量相等
   //可以使用Promise的all方法，将多个Promise合并为一个Promise进行管理

   //需要接收一个数组
   //数组中每个元素都是一个promise对象，把他们看作一个个异步任务
   //返回一个全新的promise对象
   //当所有异步任务结束后，返回的全新的promise才会完成
   //此时这个promise拿到的结果就是一个数组，在这个数组里包含每一个异步任务执行过后的结果
   var promise = Promise.all([
     ajax("/api/users.json"),
     ajax("/api/posts.json"),
   ]);
   promise.then(function (values) {
     console.log(values);
   });

   //注意：在这个任务的过程中，只有在这两个任务都成功结束了，新的promise才会成功结束
   //任何一个失败都会以失败结束

   //综合使用串联并行
   //执行过程：先请求所有url的地址，把地址拿到后，同时请求url地址数组中所有地址
   ajax("/api/urls.json")
     .then((value) => {
       const urls = Object.values(value); //获取所有的属性和值 得到一个数组
       const tasks = urls.map((url) => ajax(url)); //把数组转换成包含全部请求的promise
       return Promise.all(tasks);
     })
     .then((values) => {
       console.log(values);
     });
   ```

   - Promise.race()

     ​ 同样可以把多个 promise 对象组合成一个全新的 promise

   ```js
   const request = ajax("/api/posts.json");
   const timeout = new Promise((resolve, reject) => {
     setTimeout(() => reject(new Error("timeout")), 500);
   });

   Promise.race([requset, timeout])
     .then((value) => {
       console.log(value);
     })
     .catch((error) => {
       console.log(error);
     });
   ```

   3. 两者区别：
      - Promise.all() 等待所有任务结束
      - Promise.race() 只会等待第一个结束的任务

## 1.2.13 Promise - 执行时序 / 宏任务 vs. 微任务

1. ```js
   console.log("global start");

   Promise.resolve().then(() => {
     console.log("promise");
   });

   console.log("global end");
   //global start global end promise
   ```

2. ```js
   console.log("global start");

   Promise.resolve()
     .then(() => {
       console.log("promise");
     })
     .then(() => {
       console.log("promise 2");
     })
     .then(() => {
       console.log("promise 3");
     });
   console.log("global end");
   //global start global end promise promise 2 promise 3
   ```

3. ```js
   console.log("global start");

   setTimeout(() => {
     console.log("setTimeout");
   }, 0);

   Promise.resolve()
     .then(() => {
       console.log("promise");
     })
     .then(() => {
       console.log("promise 2");
     })
     .then(() => {
       console.log("promise 3");
     });
   console.log("global end");
   //global start global end promise promise 2 promise 3 setTimeout
   //原因：promise异步执行时序比较特殊
   ```

4. 回调队列中的任务称之为“宏任务”，宏任务在执行过程中可以临时加上一些额外的需求，可以选择作为一个新的宏任务进到回调队列中排队（例如 setTimeout 重新排队）

5. 也可以作为当前任务的“微任务”，直接在当前任务结束过后立即执行，而不是到队伍末尾重新排队

6. Promise 的回调会作为微任务执行，会在本轮调用结束末尾自动执行。

7. 所以 setTimeout 会在末尾打印

8. 微任务的概念

   - 目的：提高应用整体的响应能力

9. 目前绝大多数异步调用都是作为宏任务执行，Promise、MutationObserver 和 node 中的 process.nextTick 会作为微任务在本轮末尾执行

## 1.2.14 Generator 异步方案（上） - 回顾 Generator 函数

1. ```js
   //promise chain
   ajax("/api/url1")
     .then((value) => {
       return ajax("ajax/url2");
     })
     .then((value) => {
       return ajax("ajax/url3");
     })
     .then((value) => {
       return ajax("ajax/url4");
     })
     .catch((error) => {
       console.error(error);
     });
   ```

2. 两种更优异步编程写法：

   1. ES2015 提供的 Generator（生成器函数）:在普通函数基础之上多了一个\*，调用生成器函数并不会立即执行这个函数，而是得到一个生成器对象，直到手动调用这个对象的 next 方法，这个函数的函数体才会开始执行

      - ```js
        //生成器函数
        function* foo() {
          console.log("start");

          //可以通过yield返回一个值
          yield "foo";
        }

        const generator = foo();

        //在next返回对象拿到这个值
        const result = generator.next();
        console.log(result); //{value: "foo", done: false}
        //done属性用来表示这个生成器是否全部执行完了
        //yield暂停了生成器执行，直到外界下一次调用next会从yield位置开始执行
        ```

   - ```js
     //生成器函数
     function* foo() {
       console.log("start");

       //可以通过yield返回一个值
       //存在const里
       const res = yield "foo";
       console.log(res);
     }

     const generator = foo();

     const result = generator.next();
     console.log(result); //{value: "foo", done: false}

     //传入一个参数，会作为yield的返回值
     generator.next("bar");
     //打印结果：
     ```

   - ```js
     //生成器函数
     function* foo() {
       console.log("start");

       try {
         const res = yield "foo";
         console.log(res);
       } catch (e) {
         console.log(e);
       }
     }

     const generator = foo();

     //在next返回对象拿到这个值
     const result = generator.next();
     console.log(result); //{value: "foo", done: false}
     //done属性用来表示这个生成器是否全部执行完了

     //yield暂停了生成器执行，throw继续执行，抛出异常
     generator.throw(new Error("Generator error"));
     //打印：start {value: "foo", done: false} Error:Generator error
     ```

## 1.2.15 Generator 异步方案（中） - 体验 Generator 函数异步方案

```js
function ajax(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "json";
    //请求完成事件
    xhr.onload = function () {
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    xhr.send();
  });
}

function* main() {
  //返回一个promise对象
  const users = yield ajax("/api/users.json");
  console.log(users);

  const posts = yield ajax("/api/posts.json");
  console.log(posts);
}
const g = main();

const result = g.next(); //执行到第一个ajax调用，next返回的value就是yield返回的promise对象

//通过then指定promies回调
result.value.then((data) => {
  //再通过next把得到的data传递进去，接着执行main，拿到result
  const result2 = g.next(data);

  //判断生成器是否结束,结束递归
  if (result2.done) return;
  const result3 = result2.value.then((data) => {
    g.next(data);
  });

  if (result3.done) return;
  result3.value.then((data) => {
    g.next(data);
  });
});

//消灭回调，近乎于同步代码的体验
```

## 1.2.16 Generator 异步方案（下）- 递归执行 Generator 函数

1. 代码示例

   ```js
   function ajax(url) {
     return new Promise(function (resolve, reject) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url);
       xhr.responseType = "json";
       //请求完成事件
       xhr.onload = function () {
         if (this.status === 200) {
           resolve(this.response);
         } else {
           reject(new Error(this.statusText));
         }
       };
       xhr.send();
     });
   }

   function* main() {
     try {
       //返回一个promise对象
       const users = yield ajax("/api/users.json");
       console.log(users);

       const posts = yield ajax("/api/posts.json");
       console.log(posts);

       const url = yield ajax("/api/posts11.json");
       console.log(url);
     } catch (e) {
       console.log(e);
     }
   }

   function co(generator) {
     const g = main();

     function handleResult(result) {
       if (result.done) return; //生成器函数结束
       result.value.then(
         (data) => {
           handleResult(g.next(data));
         },
         (error) => {
           g.throw(error);
         }
       );
     }

     handleResult(g.next());
   }

   co(main);
   ```

   异步调用回归扁平化。

2. co 库：https://github.com/tj/co (2015 年前流行)，开发中还是会用 async await

## 1.2.17 Async 函数 - Async / Await 语法糖：语言层面的异步编程标准

1. 好处：不需要配合 field 执行期；async 可以返回 promise 对象

2. 需要注意：await 现在只能够出现在 async 函数内部

3. 代码：

   ```js
   function ajax(url) {
     return new Promise(function (resolve, reject) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url);
       xhr.responseType = "json";
       //请求完成事件
       xhr.onload = function () {
         if (this.status === 200) {
           resolve(this.response);
         } else {
           reject(new Error(this.statusText));
         }
       };
       xhr.send();
     });
   }

   async function main() {
     try {
       //返回一个promise对象
       const users = await ajax("/api/users.json");
       console.log(users);

       const posts = await ajax("/api/posts.json");
       console.log(posts);

       const url = await ajax("/api/posts11.json");
       console.log(url);
     } catch (e) {
       console.log(e);
     }
   }

   function co(generator) {
     const g = main();

     function handleResult(result) {
       if (result.done) return; //生成器函数结束
       result.value.then(
         (data) => {
           handleResult(g.next(data));
         },
         (error) => {
           g.throw(error);
         }
       );
     }

     handleResult(g.next());
   }

   main();
   ```

# 任务三：手写 Promise 源码

## 1.3.1 Promise 实现 - 核心逻辑实现

1. ```js
   /*
       1. Promise就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行
       2. Promise中有三种状态 分别为成功 fulfilled 失败 rejected 等待 pending
           pending -> fulfilled
           pending -> rejected
           一旦状态确定就不可更改
       3. resolve和reject函数是用来更改状态的
           resolve:fulfilled
           reject:rejected
           传递给resolve的参数就是成功之后的值
           传递给reject的参数就是失败的原因
       4. then方法内部做的事情就是判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败的回调函数 then方法是被定义在原型对象中的
       5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因
   */

   const MyPromise = require("./myPromise");

   let promise = new MyPromise((resolve, reject) => {
     resolve("成功");
     // reject("失败");
   });
   //调用then时，先判断状态，成功调用前一个，失败调用后一个
   promise.then(
     (value) => {
       console.log(value);
     },
     (reason) => {
       console.log(reason);
     }
   );
   ```

2. ```js
   const PENDING = "pending"; // 等待
   const FULFILLED = "fulfilled"; // 成功
   const REJECTED = "rejected"; // 失败

   class MyPromise {
     constructor(executor) {
       executor(this.resolve, this.reject);
     }
     status = PENDING;
     // 成功之后的值
     value = undefined;
     // 失败后的原因
     reason = undefined;

     // 箭头函数使得this指向这个promise
     resolve = (value) => {
       // 如果状态不是等待 阻止程序向下执行
       if (this.stauts !== PENDING) return;
       // 将状态更改为成功
       this.status = FULFILLED;
       // 保存成功之后的值
       this.value = value;
     };
     reject = (reason) => {
       if (this.stauts !== PENDING) return;
       // 将状态更改为失败
       this.status = REJECTED;
       // 保存失败之后的原因
       this.reason = reason;
     };
     then(successCallback, failCallback) {
       // 判断状态
       if (this.status === FULFILLED) {
         successCallback(this.value);
       } else if (this.status === REJECTED) {
         failCallback(this.reason);
       }
     }
   }

   // 导出
   module.exports = MyPromise;
   ```

## 1.3.2 Promise 实现 - 加入异步逻辑

1. ```js
   /*
       1. Promise就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行
       2. Promise中有三种状态 分别为成功 fulfilled 失败 rejected 等待 pending
           pending -> fulfilled
           pending -> rejected
           一旦状态确定就不可更改
       3. resolve和reject函数是用来更改状态的
           resolve:fulfilled
           reject:rejected
           传递给resolve的参数就是成功之后的值
           传递给reject的参数就是失败的原因
       4. then方法内部做的事情就是判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败的回调函数 then方法是被定义在原型对象中的
       5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因
   */

   const MyPromise = require("./myPromise");

   let promise = new MyPromise((resolve, reject) => {
     setTimeout(() => {
       resolve("成功");
     }, 2000);

     // reject("失败");
   });
   //调用then时，先判断状态，成功调用前一个，失败调用后一个
   promise.then(
     (value) => {
       console.log(value);
     },
     (reason) => {
       console.log(reason);
     }
   );
   ```

2. ```js
   const PENDING = "pending"; // 等待
   const FULFILLED = "fulfilled"; // 成功
   const REJECTED = "rejected"; // 失败

   class MyPromise {
     constructor(executor) {
       executor(this.resolve, this.reject);
     }
     status = PENDING;
     // 成功之后的值
     value = undefined;
     // 失败后的原因
     reason = undefined;

     //成功回调
     successCallback = undefined;
     //失败回调
     failCallback = undefined;
     // 箭头函数使得this指向这个promise
     resolve = (value) => {
       // 如果状态不是等待 阻止程序向下执行
       if (this.stauts !== PENDING) return;
       // 将状态更改为成功
       this.status = FULFILLED;
       // 保存成功之后的值
       this.value = value;
       // 判断成功回调是否存在 如果存在 调用
       this.successCallback && this.successCallback(this.value);
     };
     reject = (reason) => {
       if (this.stauts !== PENDING) return;
       // 将状态更改为失败
       this.status = REJECTED;
       // 保存失败之后的原因
       this.reason = reason;
       // 判断失败回调是否存在 如果存在 调用
       this.failCallback && this.failCallback(this.reason);
     };
     then(successCallback, failCallback) {
       // 判断状态
       if (this.status === FULFILLED) {
         successCallback(this.value);
       } else if (this.status === REJECTED) {
         failCallback(this.reason);
       } else {
         //等待
         //将成功回调和失败回调存储起来
         this.successCallback = successCallback;
         this.failCallback = failCallback;
       }
     }
   }

   // 导出
   module.exports = MyPromise;
   ```

## 1.3.3 Promise 实现 - 实现 then 方法多次调用

1. 分为两种情况：

   - 同步情况：已经成功或失败：调用
   - 异步情况：每一个 then 都应该存储起来

2. ```js
   /*
       1. Promise就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行
       2. Promise中有三种状态 分别为成功 fulfilled 失败 rejected 等待 pending
           pending -> fulfilled
           pending -> rejected
           一旦状态确定就不可更改
       3. resolve和reject函数是用来更改状态的
           resolve:fulfilled
           reject:rejected
           传递给resolve的参数就是成功之后的值
           传递给reject的参数就是失败的原因
       4. then方法内部做的事情就是判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败的回调函数 then方法是被定义在原型对象中的
       5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因
   */

   const MyPromise = require("./myPromise");

   let promise = new MyPromise((resolve, reject) => {
     // setTimeout(() => {
     //   resolve("成功");
     // }, 2000);
     resolve("成功");
     // reject("失败");
   });
   //调用then时，先判断状态，成功调用前一个，失败调用后一个
   promise.then((value) => {
     console.log(value);
   });
   promise.then((value) => {
     console.log(value);
   });
   promise.then((value) => {
     console.log(value);
   });
   ```

3. ```js
   const PENDING = "pending"; // 等待
   const FULFILLED = "fulfilled"; // 成功
   const REJECTED = "rejected"; // 失败

   class MyPromise {
     constructor(executor) {
       executor(this.resolve, this.reject);
     }
     status = PENDING;
     // 成功之后的值
     value = undefined;
     // 失败后的原因
     reason = undefined;

     //成功回调
     successCallback = [];
     //失败回调
     failCallback = [];

     // 箭头函数使得this指向这个promise
     resolve = (value) => {
       // 如果状态不是等待 阻止程序向下执行
       if (this.stauts !== PENDING) return;
       // 将状态更改为成功
       this.status = FULFILLED;
       // 保存成功之后的值
       this.value = value;
       // 判断成功回调是否存在 如果存在 调用
       //this.successCallback && this.successCallback(this.value);
       //循环数组
       while (this.successCallback.length)
         this.successCallback.shift()(this.value);
     };
     reject = (reason) => {
       if (this.stauts !== PENDING) return;
       // 将状态更改为失败
       this.status = REJECTED;
       // 保存失败之后的原因
       this.reason = reason;
       // 判断失败回调是否存在 如果存在 调用
       //this.failCallback && this.failCallback(this.reason);
       //shift会删除值
       while (this.failCallback.length) this.failCallback.shift()(this.reason);
     };
     then(successCallback, failCallback) {
       // 判断状态
       if (this.status === FULFILLED) {
         successCallback(this.value);
       } else if (this.status === REJECTED) {
         failCallback(this.reason);
       } else {
         //等待
         //将成功回调和失败回调存储起来
         this.successCallback.push(successCallback);
         this.failCallback.push(failCallback);
       }
     }
   }

   // 导出
   module.exports = MyPromise;
   ```

## 1.3.4 Promise 实现 - 实现 then 方法的链式调用（上）

1. then 拿到的值是上一个 then 的返回值。

   ```js
   promise
     .then((value) => {
       console.log(value); // 成功
       return 100;
       //下面的value即100
     })
     .then((value) => {
       console.log(value); // 100
     });
   ```

2. 如果想要实现 then 的链式调用，每一个 then 方法都应该返回 Promise 对象。

   - 实现第一个需求：then 返回 promise 对象

     ```js
       then(successCallback, failCallback) {
         let promise2 = new MyPromise(() => {
           // 判断状态
           if (this.status === FULFILLED) {
             successCallback(this.value);
           } else if (this.status === REJECTED) {
             failCallback(this.reason);
           } else {
             //等待
             //将成功回调和失败回调存储起来
             this.successCallback.push(successCallback);
             this.failCallback.push(failCallback);
           }
         });
         return promise2;
       }
     ```

   - 拿到返回值

     ```js
       then(successCallback, failCallback) {
         let promise2 = new MyPromise((resolve, reject) => {
           // 判断状态
           if (this.status === FULFILLED) {
             let x = successCallback(this.value);
             resolve(x);
           } else if (this.status === REJECTED) {
             failCallback(this.reason);
           } else {
             //等待
             //将成功回调和失败回调存储起来
             this.successCallback.push(successCallback);
             this.failCallback.push(failCallback);
           }
         });
         return promise2;
       }
     ```

## 1.3.5 Promise 实现 - 实现 then 方法的链式调用（下）

1. ```js
   const MyPromise = require("./myPromise");

   let promise = new MyPromise((resolve, reject) => {
     // setTimeout(() => {
     //   resolve("成功");
     // }, 2000);
     resolve("成功");
     // reject("失败");
   });

   function other() {
     return new MyPromise((resolve, reject) => {
       resolve("other");
     });
   }

   promise
     .then((value) => {
       console.log(value); // 成功
       return other();
     })
     .then((value) => {
       console.log(value);
     });
   ```

2. ```js
   const PENDING = "pending"; // 等待
   const FULFILLED = "fulfilled"; // 成功
   const REJECTED = "rejected"; // 失败

   class MyPromise {
     constructor(executor) {
       executor(this.resolve, this.reject);
     }
     status = PENDING;
     // 成功之后的值
     value = undefined;
     // 失败后的原因
     reason = undefined;

     //成功回调
     successCallback = [];
     //失败回调
     failCallback = [];

     // 箭头函数使得this指向这个promise
     resolve = (value) => {
       // 如果状态不是等待 阻止程序向下执行
       if (this.stauts !== PENDING) return;
       // 将状态更改为成功
       this.status = FULFILLED;
       // 保存成功之后的值
       this.value = value;
       // 判断成功回调是否存在 如果存在 调用
       //this.successCallback && this.successCallback(this.value);
       //循环数组
       while (this.successCallback.length)
         this.successCallback.shift()(this.value);
     };
     reject = (reason) => {
       if (this.stauts !== PENDING) return;
       // 将状态更改为失败
       this.status = REJECTED;
       // 保存失败之后的原因
       this.reason = reason;
       // 判断失败回调是否存在 如果存在 调用
       //this.failCallback && this.failCallback(this.reason);
       //shift会删除值
       while (this.failCallback.length) this.failCallback.shift()(this.reason);
     };
     then(successCallback, failCallback) {
       let promise2 = new MyPromise((resolve, reject) => {
         // 判断状态
         if (this.status === FULFILLED) {
           let x = successCallback(this.value);
           //判断 x 的值是普通值还是promise对象
           //如果是普通值 直接调用resolve
           //如果是promise对象 查看promise对象返回的结果
           //再根据promise对象返回的结果 决定调用resolve 还是调用reject
           resolvePromise(x, resolve, reject);
         } else if (this.status === REJECTED) {
           failCallback(this.reason);
         } else {
           //等待
           //将成功回调和失败回调存储起来
           this.successCallback.push(successCallback);
           this.failCallback.push(failCallback);
         }
       });

       return promise2;
     }
   }
   function resolvePromise(x, resolve, reject) {
     if (x instanceof MyPromise) {
       //promise 对象
       // x.then(
       //   (value) => {
       //     resolve(value);
       //   },
       //   (reason) => {
       //     reject(reason);
       //   }
       // );
       x.then(resolve, reject);
     } else {
       //普通值
       resolve(x);
     }
   }

   // 导出
   module.exports = MyPromise;
   ```

## 1.3.6 Promise 实现 - then 方法链式调用识别 Promise 对象自返回

1. 有一种情况例外：在 then 方法的回调函数当中是不能返回当前 then 方法所返回的 promise 对象，会发生循环调用，会报错，例子：

   ```js
   var promise = new Promise(function (resolve, reject) {
     resolve(100);
   });

   var p1 = promise.then(function (value) {
     console.log(value);
     return p1; //发生循环调用：
     //如果不写下面的catch的话会打印出：100 Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
   });

   p1.then(
     function () {},
     function (reason) {
       console.log(reason.message); //test.html:22 Chaining cycle detected for promise #<Promise>
     }
   );
   ```

2. solution：

   ```js
   then(successCallback, failCallback) {
       let promise2 = new MyPromise((resolve, reject) => {
         // 判断状态
         if (this.status === FULFILLED) {
           //异步获取promise2
           setTimeout(() => {
             let x = successCallback(this.value);
             //判断 x 的值是普通值还是promise对象
             //如果是普通值 直接调用resolve
             //如果是promise对象 查看promise对象返回的结果
             //再根据promise对象返回的结果 决定调用resolve 还是调用reject
             resolvePromise(promise2, x, resolve, reject);
           }, 0);
         } else if (this.status === REJECTED) {
           failCallback(this.reason);
         } else {
           //等待
           //将成功回调和失败回调存储起来
           this.successCallback.push(successCallback);
           this.failCallback.push(failCallback);
         }
       });

       return promise2;
     }

   function resolvePromise(promise2, x, resolve, reject) {
     if (promise2 === x) {
       return reject(
         new TypeError("Chaining cycle detected for promise #<Promise>")
       );
     }
     if (x instanceof MyPromise) {
       //promise 对象
       // x.then(
       //   (value) => {
       //     resolve(value);
       //   },
       //   (reason) => {
       //     reject(reason);
       //   }
       // );
       x.then(resolve, reject);
     } else {
       //普通值
       resolve(x);
     }
   }
   ```

   ```js
   let p1 = promise.then((value) => {
     console.log(value); // 成功
     return p1;
   });

   p1.then(
     (value) => {
       console.log(value);
     },
     (reason) => {
       console.log(reason.message);
     }
   );
   ```

## 1.3.7 Promise 实现 - 捕获错误及 then 链式调用其他状态代码补充 (try catch)

1. 捕获执行器错误：

   ```js
     constructor(executor) {
       try {
         executor(this.resolve, this.reject);
       } catch (e) {
         this.reject(e);
       }
     }
   ```

2. then 执行中报错在下一个 then 捕获：

   ```js
   const PENDING = "pending"; // 等待
   const FULFILLED = "fulfilled"; // 成功
   const REJECTED = "rejected"; // 失败

   class MyPromise {
     constructor(executor) {
       try {
         executor(this.resolve, this.reject);
       } catch (e) {
         this.reject(e);
       }
     }
     status = PENDING;
     // 成功之后的值
     value = undefined;
     // 失败后的原因
     reason = undefined;

     //成功回调
     successCallback = [];
     //失败回调
     failCallback = [];

     // 箭头函数使得this指向这个promise
     resolve = (value) => {
       // 如果状态不是等待 阻止程序向下执行
       if (this.stauts !== PENDING) return;
       // 将状态更改为成功
       this.status = FULFILLED;
       // 保存成功之后的值
       this.value = value;
       // 判断成功回调是否存在 如果存在 调用
       //this.successCallback && this.successCallback(this.value);
       //循环数组
       while (this.successCallback.length) this.successCallback.shift()();
     };
     reject = (reason) => {
       if (this.stauts !== PENDING) return;
       // 将状态更改为失败
       this.status = REJECTED;
       // 保存失败之后的原因
       this.reason = reason;
       // 判断失败回调是否存在 如果存在 调用
       //this.failCallback && this.failCallback(this.reason);
       //shift会删除值
       while (this.failCallback.length) this.failCallback.shift()(this.reason);
     };
     then(successCallback, failCallback) {
       let promise2 = new MyPromise((resolve, reject) => {
         // 判断状态
         if (this.status === FULFILLED) {
           //异步获取promise2
           setTimeout(() => {
             try {
               let x = successCallback(this.value);
               //判断 x 的值是普通值还是promise对象
               //如果是普通值 直接调用resolve
               //如果是promise对象 查看promise对象返回的结果
               //再根据promise对象返回的结果 决定调用resolve 还是调用reject
               resolvePromise(promise2, x, resolve, reject);
             } catch (e) {
               reject(e);
             }
           }, 0);
         } else if (this.status === REJECTED) {
           setTimeout(() => {
             try {
               let x = failCallback(this.reason);
               resolvePromise(promise2, x, resolve, reject);
             } catch (e) {
               reject(e);
             }
           }, 0);
         } else {
           //等待
           //将成功回调和失败回调存储起来
           this.successCallback.push(() => {
             successCallback();
             setTimeout(() => {
               try {
                 let x = successCallback(this.value);
                 resolvePromise(promise2, x, resolve, reject);
               } catch (e) {
                 reject(e);
               }
             }, 0);
           });
           this.failCallback.push(() => {
             failCallback();
             setTimeout(() => {
               try {
                 let x = failCallback(this.reason);
                 resolvePromise(promise2, x, resolve, reject);
               } catch (e) {
                 reject(e);
               }
             }, 0);
           });
         }
       });

       return promise2;
     }
   }
   function resolvePromise(promise2, x, resolve, reject) {
     if (promise2 === x) {
       return reject(
         new TypeError("Chaining cycle detected for promise #<Promise>")
       );
     }
     if (x instanceof MyPromise) {
       //promise 对象
       // x.then(
       //   (value) => {
       //     resolve(value);
       //   },
       //   (reason) => {
       //     reject(reason);
       //   }
       // );
       x.then(resolve, reject);
     } else {
       //普通值
       resolve(x);
     }
   }

   // 导出
   module.exports = MyPromise;
   ```

## 1.3.8 Promise 实现 - 将 then 方法的参数变成可选参数

1. then 方法有两个参数，一个是成功回调，一个是失败回调。这两个参数实际上都是可选参数。then 可以不传递任何参数。

   ```js
   var promise = new Promise(function (resolve, reject) {
     resolve(100);
   });
   promise
     .then()
     .then()
     .then((value) => console.log(value)); // print 100
   ```

   在这种情况下（第三次才传递成功的回调函数），promise 的状态会依次向后传递，比如说先传递给了第一个 then，有传递给了第二个 then，一直传递给有回调的 then 方法也就是第三个 then。

   等同于：

   ```js
   promise
     .then((value) => value)
     .then((value) => value)
     .then((value) => console.log(value)); // print 100
   ```

2. 在自己写的 promise 中的 then 方法中则要在第一行加两句判断：

   ```js
   successCallback = successCallback ? successCallback : (value) => value;
   failCallback = failCallback
     ? failCallback
     : (reason) => {
         throw reason;
       };
   ```

## 1.3.9 Promise 实现 - Promise.all 方法的实现

1. 用来解决异步并发的问题，允许按照异步代码调用的顺序得到异步代码执行的结果。是一个静态方法。

2. 具体语法：

   - 接收一个数组作为参数
   - 在这个数组中可以填入任何值，可以普通值也可以 promise 对象
   - 数组当中值的顺序一定是得到的结果的顺序
   - 后面可链式调用 then 方法
     - 在 all 方法中所有 promise 对象如果状态都是成功的，all 方法最后的结果也是成功的
     - 如果有一个是失败的，最终结果就是失败的
   - all 方法返回的也是一个 promise 对象

3. 代码案例：

   ```js
   function p1() {
     return new Promise(function (resolve, reject) {
       setTimeout(function () {
         resolve("p1");
       }, 2000);
     });
   }
   function p2() {
     return new Promise(function (resolve, reject) {
       resolve("p2");
     });
   }
   Promise.all(["a", "b", p1(), p2(), "c"]).then(function (result) {
     //result => ['a','b','p1','p2','c']
   });
   ```

4. 自己实现：

   ```js
     static all(array) {
       let result = [];
       let index = 0;

       return new MyPromise((resolve, reject) => {
         function addData(key, value) {
           result[key] = value;
           index++;
           if (index === array.length) {
             resolve(result);
           }
         }
         for (let i = 0; i < array.length; i++) {
           let current = array[i];
           if (current instanceof MyPromise) {
             //promise对象
             current.then(
               (value) => {
                 addData(i, value);
               },
               (reason) => {
                 reject(reason);
               }
             );
           } else {
             // 普通值
             addData(i, array[i]);
           }
         }
         resolve(result);
       });
     }
   ```

## 1.3.10 Promise 实现 - Promise.resolve 方法的实现

1. resolve 方法的内部会创建一个 promise 对象，把传入的普通值包裹进去，把这个创建出来的 promise 对象作为 resolve 返回值。这样才能在后面 then 方法成果回调函数拿到这个值。 如果传入的是 promise 对象，则会原封不动的返回这个 promise 对象。

   ```js
   function p1() {
     return new Promise(function (resolve, reject) {
       resolve("hello");
     });
   }
   Promise.resolve(10).then((value) => console.log(value)); // 10
   Promise.resolve(p1()).then((value) => console.log(value)); // hello
   ```

2. 自己实现：

   ```js
     static resolve(value) {
       if (value instanceof MyPromise) {
         return value;
       } else {
         return new MyPromise((resolve) => resolve(value));
       }
     }
   ```

## 1.3.11 Promise 实现 - finally 方法的实现

1. 两个特点：

   - 无论当前 promise 对象最终状态是成功还是失败，finally 中的回调函数始终都会被执行一次。
   - finally 后面可以链式调用 then 方法来拿到当前 promise 对象最终返回的结果。（在 finally 里拿不到）

   ```js
   function p1() {
     return new Promise(function (resolve, reject) {
       resolve("hello");
     });
   }
   p1()
     .finally(() => {
       console.log("finally");
     })
     .then((value) => {
       console.log(value);
     });
   ```

2. 自己实现：不是一个静态方法，需要定义在 MyPromise 原型对象身上。

   ```js
     finally(callback) {
       return this.then(
         (value) => {
           callback();
           return value;
         },
         (reason) => {
           callback(reason);
           throw reason;
         }
       );
     }
   ```

3. 另外一个需求：在 finally 方法里 return 一个异步 promise，等待完成后再执行 then

   ```js
     finally(callback) {
       return this.then(
         (value) => {
           return MyPromise.resolve(callback()).then(() => {
             value;
           });
         },
         (reason) => {
           return MyPromise.resolve(callback()).then(() => {
             throw reason;
           });
         }
       );
     }
   ```

## 1.3.12 Promise 实现 - catch 方法的实现

1. 用来处理当前 promise 对象最终状态为失败的情况。

   - 调用 then 方法可以不传递失败回调，失败回调就会被 catch 方法捕获

   ```js
   function p1() {
     return new Promise(function (resolve, reject) {
       resolve("hello");
     });
   }
   p1()
     .then((value) => console.log(value))
     .catch((reason) => console.log(reason));
   ```

2. 自己实现：

   ```js
     catch(failCallback) {
       return this.then(undefined, failCallback);
     }
   ```
